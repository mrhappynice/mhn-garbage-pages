<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Canvas Text v3.1</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 1.5rem;
      gap: 1rem;
      background: radial-gradient(circle at top, #333, #050505 60%);
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    h1 {
      font-weight: 600;
      font-size: 1.3rem;
      margin: 0;
      text-align: center;
      opacity: 0.8;
    }

    .controls {
      display: flex;
      gap: 0.5rem;
      width: 100%;
      max-width: 640px;
    }

    .controls input[type="text"] {
      flex: 1;
      padding: 0.5rem 0.75rem;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(0, 0, 0, 0.45);
      color: #eee;
      font-size: 0.95rem;
      outline: none;
      transition: border-color 0.2s;
    }
    .controls input[type="text"]:focus {
      border-color: rgba(255, 255, 255, 0.6);
    }

    .controls input[type="text"]::placeholder {
      color: rgba(255, 255, 255, 0.4);
    }

    .controls button {
      padding: 0.5rem 1rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      background: linear-gradient(135deg, #f5f5f5, #bbbbbb);
      color: #111;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.6);
      white-space: nowrap;
      transition: transform 0.1s;
    }
    .controls button:active {
      transform: scale(0.96);
    }

    #artContainer {
      background: #000;
      padding: 1rem;
      border-radius: 16px;
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
      width: 100%;
      max-width: 900px;
      /* Allow height to grow but limit width */
      overflow: visible; 
      min-height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #artContainer svg {
      display: block;
      width: 100%;
      height: auto;
    }

    #hiddenCanvas {
      display: none;
    }

    /* 
       ANIMATION LOGIC:
       1. ghost-enter: Runs once. Handles the fade in + blur + scale up.
       2. shimmer: Runs infinitely. Handles the jitter.
    */
    .sparkle-shape {
      transform-origin: center;
      opacity: 0; /* Start invisible */
      /* Combining animations: Enter (once) + Shimmer (infinite) */
      animation: 
        ghost-enter 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards,
        shimmer 2s ease-in-out infinite alternate;
    }

    /* The entrance effect */
    @keyframes ghost-enter {
      0% {
        opacity: 0;
        transform: scale(0);
        filter: blur(4px);
      }
      60% {
        opacity: 1;
        filter: blur(0px);
      }
      100% {
        opacity: 1;
        transform: scale(1);
        filter: blur(0px);
      }
    }

    /* The idle effect */
    @keyframes shimmer {
      0% {
        transform: translate(0px, 0px) scale(1);
        opacity: 0.8;
      }
      50% {
        transform: translate(0.1px, -0.1px) scale(1.01);
        opacity: 1;
      }
      100% {
        transform: translate(-0.1px, 0.1px) scale(1);
        opacity: 0.85;
      }
    }
  </style>
</head>
<body>
  <h1>Canvas Text v3.1</h1>

  <div class="controls">
    <input
      id="textInput"
      type="text"
      placeholder="Type a long message..."
      value="The quick brown fox jumped..."
    />
    <button id="renderBtn">Render</button>
  </div>

  <div id="artContainer"></div>
  <canvas id="hiddenCanvas"></canvas>

  <script>
    const artContainer = document.getElementById("artContainer");
    const canvas = document.getElementById("hiddenCanvas");
    const ctx = canvas.getContext("2d");
    const textInput = document.getElementById("textInput");
    const renderBtn = document.getElementById("renderBtn");

    const CELL_SIZE = 9;   
    const FONT_SIZE = 100; 
    const LINE_HEIGHT = FONT_SIZE * 1.1;

    function renderSparkleText(text) {
      text = text || "";
      if (!text.trim()) {
        artContainer.innerHTML = "";
        return;
      }

      // 1. Determine wrapping limits
      // We limit the internal canvas width to ensure wrapping happens
      // Max width is roughly the container width minus padding
      const maxLineWidth = Math.min(window.innerWidth - 60, 850); 
      
      // 2. Prepare Font for measurement
      ctx.font = `bold ${FONT_SIZE}px monospace`;
      ctx.textBaseline = "top";

      // 3. Wrap Text Logic
      const words = text.split(" ");
      let lines = [];
      let currentLine = words[0];

      for (let i = 1; i < words.length; i++) {
        let testLine = currentLine + " " + words[i];
        let metrics = ctx.measureText(testLine);
        if (metrics.width > maxLineWidth) {
          lines.push(currentLine);
          currentLine = words[i];
        } else {
          currentLine = testLine;
        }
      }
      lines.push(currentLine);

      // 4. Calculate final canvas size
      const padding = 20;
      // Find widest line for strict canvas width
      let maxMeasuredWidth = 0;
      lines.forEach(line => {
        const w = ctx.measureText(line).width;
        if(w > maxMeasuredWidth) maxMeasuredWidth = w;
      });

      canvas.width = Math.ceil(maxMeasuredWidth + padding * 2);
      canvas.height = Math.ceil((lines.length * LINE_HEIGHT) + padding * 2);

      // 5. Draw Text to Canvas (White on Black)
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "white";
      ctx.font = `bold ${FONT_SIZE}px monospace`; // Re-set font after resize
      ctx.textBaseline = "top";

      lines.forEach((line, index) => {
        ctx.fillText(line, padding, padding + (index * LINE_HEIGHT));
      });

      // 6. Sample Data
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imgData.data;

      const cols = Math.floor(canvas.width / CELL_SIZE);
      const rows = Math.floor(canvas.height / CELL_SIZE);
      const shapes = [];

      // 7. Generate Shapes with "Typewriter" Delays
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const brightness = sampleCellBrightness(data, x, y, CELL_SIZE, canvas.width, canvas.height);
          const norm = brightness / 255;

          if (norm < 0.1) continue;

          const cx = x * CELL_SIZE + CELL_SIZE / 2;
          const cy = y * CELL_SIZE + CELL_SIZE / 2;

          // Calculate "Typing" Delay
          // X creates a small delay (writing a line)
          // Y creates a larger delay (moving down lines)
          // Factor 0.015 controls typing speed
          const typeDelay = (x * 0.015) + (y * 0.1); 

          const shape = makeSparkleShape(norm, cx, cy, CELL_SIZE, typeDelay);
          if (shape) shapes.push(shape);
        }
      }

      // 8. Output SVG
      const svg = `
        <svg xmlns="http://www.w3.org/2000/svg"
             viewBox="0 0 ${canvas.width} ${canvas.height}"
             width="${canvas.width}" height="${canvas.height}">
          <rect width="100%" height="100%" fill="black" />
          ${shapes.join("\n")}
        </svg>
      `.trim();

      artContainer.innerHTML = svg;
    }

    function sampleCellBrightness(data, cellX, cellY, cellSize, width, height) {
      let sum = 0;
      let count = 0;
      const startX = cellX * cellSize;
      const startY = cellY * cellSize;

      for (let y = startY; y < startY + cellSize && y < height; y += 2) {
        for (let x = startX; x < startX + cellSize && x < width; x += 2) {
          const idx = (y * width + x) * 4;
          // Simple grayscale
          const bVal = (data[idx] + data[idx+1] + data[idx+2]) / 3;
          sum += bVal;
          count++;
        }
      }
      return count > 0 ? sum / count : 0;
    }

    function makeSparkleShape(norm, cx, cy, cellSize, typeDelay) {
      const baseSize = norm * cellSize;
      const jitter = (Math.random() - 0.5) * 0.2 * baseSize;
      const size = Math.max(0.6, baseSize + jitter);

      // Random offset for the shimmer loop so they don't pulse in unison
      const shimmerDelay = (Math.random() * 2).toFixed(2);
      
      // Combine delays: 
      // The element waits for 'typeDelay' to start entrance.
      // The shimmer animation also respects this delay.
      const totalStyle = `animation-delay: ${typeDelay.toFixed(2)}s, ${shimmerDelay}s;`;

      if (Math.random() < 0.5) {
        // Circle
        const r = size / 2;
        return `<circle cx="${cx.toFixed(2)}" cy="${cy.toFixed(2)}" r="${r.toFixed(2)}"
          fill="white"
          class="sparkle-shape"
          style="${totalStyle}" />`;
      } else {
        // Diamond
        const half = size / 2;
        const pts = [
          `${cx},${cy - half}`,
          `${cx + half},${cy}`,
          `${cx},${cy + half}`,
          `${cx - half},${cy}`
        ].join(" ");
        return `<polygon points="${pts}" fill="white"
          class="sparkle-shape"
          style="${totalStyle}" />`;
      }
    }

    renderBtn.addEventListener("click", () => renderSparkleText(textInput.value));
    textInput.addEventListener("keyup", (e) => {
      if (e.key === "Enter") renderSparkleText(textInput.value);
    });
    
    // Handle Window Resize to re-wrap text
    let resizeTimeout;
    window.addEventListener("resize", () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        renderSparkleText(textInput.value);
      }, 300);
    });

    // Initial render
    renderSparkleText(textInput.value);
  </script>
</body>
</html>
